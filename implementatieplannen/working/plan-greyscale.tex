\documentclass[a4paper]{article}
\usepackage{amsmath}
\usepackage{hyperref}

\begin{document}
\title{Conversion of RGB images to Intensity images}
\author{Niels de Waal (1698041), Jasper Smienk(103967)}
\maketitle
\newpage

\tableofcontents
\newpage

\section{Target}
The assignment of TICT-V2VISN1-13 at the HU, which we have chosen to undertake consists of two different components.
The first one consists of writing a image shell which has to ability to extract or modify data from a given image.
The second assignment is to convert an RGB image to an intensity/grey-scale image. 

We will be mostly focusing on the second assignment. This is because we are interested in comparing a few different approaches to this problem.

For the second assignment we will be doing two measuring tests. The first will cover speed across multiple methods of grey-scaling. The second test will revolve around parallel execution of the grey-scaling process.

Both can be of interest. This could be because testing multiple methods of grey-scaling, including testing the speed at which this can be done could have effects when grey-scaling becomes an integral part of a system. This could happen in a real-time face recognition system, where grey-scaling has to be done every frame.

\section{Methods}
In this section we will discuss several methods of grey-scaling an image.

Let us refer to pixel \(i\) as part of image \(P\), where \(i \in \{0, \dotsc , \left( P_{width} * P_{height} \right) - 1 \} \). Every \(i\) has a set of \( \left(R, G, B \right) \) where \(R\), \(G\) and \(B\) have a range \(\{0, \dotsc ,255 \} \).

\subsection{Methods for grey-scaling}
In this sections a few methods for grey-scaling will be discussed.
There are far too many methods to compare them all, thus in this article we will discuss these three:
\begin{itemize}
\item Averaging
\item Luma
\item Decomposition
\end{itemize}
\subsubsection{Averaging}
This will be considered as the naive approach to grey-scaling. Here we take the RGB values and using the average of them to calculate the grey-scale value. 
With the values: \( \forall i \in P \) the grey-scale is \( \left( i_{R} + i_{G} + i_{B} \right) \div 3 \).

This technique has the advantage that it is very easy to implement and cheap to run. It has the disadvantage that it is not a very good at giving a good representation of a grey-scale image for human eyes.

\subsubsection{Luma}
The luma method fixes the problem that averaging has regarding the correctness for the human eye. Luma gives different priorities to different channels. The values for the different channels are described in \cite{HDTV-REC}.
With the values: \( \forall i \in P \) the grey-scale is \(  i_{R}*0.2126 + i_{G}*0.7152 + i_{B}*0.0722  \).

With this method we could lose speed in comparison to averaging, because of the multiple floating point operations that have to be done each pixel. The upside is that this method delivers better images, because they are suited for the human eye.

\subsubsection{Decomposition}
Decomposition is the simplest method of grey-scaling. This method of grey-scaling has the advantage that it is very cheap to implement and run. The disadvantage is that, depending on the version used, it can result in a vastly lighter or darker image. 
With the values: \( \forall i \in P \) the grey-scale is \(  \max(i_{R}, i_{G}, i_{B}) \) or \(  \min(i_{R}, i_{G}, i_{B}) \).

This method is not adjusted for the human eye. 

\subsection{Parallel execution of grey-scaling}
Grey-scaling an image is often used in computer vision because it makes it easier for the algorithms to recognize edges. When this step has to be done in a real-time system, the amount of processing needed could add up to have a noticeable effect. With this section we explain the 2 possible methods of decreasing the workload caused by grey-scaling. Namely we chose to investigate these two methods:
\begin{itemize}
\item SIMD
\item OpenCL
\end{itemize}

\subsubsection{SIMD}
SIMD or "Single Instruction, Multiple Data" describes the action of performing the same action on multiple data points. It can add parallelism to data by performing one instruction on multiple data points at once.

SIMD was introduced in the early 1970s by vector supercomputers, e.g \cite{TI-ASC}.
Intel was the first to bring SIMD to consumer processors with MMX\cite{INTEL-MMX} on the x86 architecture.

The biggest advantage of SIMD comes when a pieces of data need to have the same operation applied to them using some constant and aren't depended on the outcome of the other data points. For example when 4 points on a 2D plane need to be shifted 4 positions, this can be efficiently done using SIMD.

SIMD could be of interest for grey-scaling because of it's parallelism on data points. This is especially of interest to us because all of the above mentioned methods for grey-scaling use only data from the same pixel. This means that we can do up to 

\subsubsection{OpenCL}

\section{Choice}

\section{Implementation}

\section{Evaluation}

\begin{thebibliography}{9}

\bibitem{HDTV-REC}
	ITU-R,
	Recommendation  ITU-R  BT.709-6,	
	\url{http://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.709-6-201506-I!!PDF-E.pdf}
  
\bibitem{TI-ASC}
	Texas Instruments,
	\url{https://en.wikipedia.org/wiki/TI_Advanced_Scientific_Computer}
 
\bibitem{INTEL-MMX}
Intel,
Pentium processor with MMX,
\url{https://www.intel.com/content/www/us/en/intelligent-systems/previous-generation/embedded-pentium-mmx.html}

\end{thebibliography}
\end{document}